## 前端测试

### 课前
- 为什么要开这个课？
	- 多年面试体会，发现面试者存在问题
		- 方向偏，没找对路
		- 知识点很简单，不知道没法答
		- 或者不知道要了解这么深入
	- 所以愿望是给前端一个类似大纲的东西，哪些东西需要学，哪些东西是首先需要攻破的，哪些东西学了以后对未来的成长比较有帮助

	- 目标：BATTMDJ / 20w
	- 课程内容：
		- 基础，与框架无关，决定未来成长的瓶颈（打好基础，然后把自己的框架能力再提升上来）
		- 深化内容：React（框架体系、全家桶，成套体系蛮难，需要懂更多东西，Vue入门简单）、Node
		- 用React和Node来告诉大家学习一个东西研究到多深才叫做懂，在大公司学习到怎么样才叫符合要求
	- 面试技巧
		- 面试套路
		- 类似高中作文的套路、方法论
		- 选取一些优秀的同学进入一个小炉灶，大部分跟上课程，并且能符合面试条件，全程review一次面试过程，安排一次模拟面试
		- 一步一个阶梯：创业公司（BAT面试官）——中间一点的公司——一二线公司——BAT（慢慢积累自己信心的过程）
		- 面的主要是基础,React和Node只是考察研究多深，其他就是一些隐藏能力的考察
		- 知行合一，知道的转化为你能做到的、转换成你能讲的东西、转换成你能够跟不懂的人说清楚

- 如何达到课程目标？这门课程如何学习？（其实也是技术学习路线和工作方法）
1. 你要知道怎么做（**使用**，用没用过）
2. **原理**是什么
3. 你要知道**优劣**是什么
4. 你要知道在当前环境下如何**选择**
5. 选择过后怎样把自己的**成本**降到最低（维护成本、失败成本、开发成本、运行成本等等）

不要限于“我知道”，而是在变化的时候知道自己该怎么做

- 模拟面试情况
	- 有一定的基础，工作中遇到问题、解决问题，但不够深入，[面试总结1](https://github.com/FE-star/2018.6/issues/4),、[面试总结2](http://note.youdao.com/noteshare?id=ce706aa892b8fdd2ffb4451776d0bb06)
	- 什么叫深入？
		- 对一个东西知不知道他的原理是什么
		- 优缺点是什么
		- 实际的工作场景中应该怎么选择

	- 基础课里面其实没有一个是难点，难的是**深刻了解、知道有哪些可能性、原理、选型**
	- 关于看文章
		- 看文章和自己真正get到是两回事
		- 面试过程中感觉到的一个事情（以框架对比为例）
			- 很多同学对框架对比以及实现原理是通过看文章看到的
			- 文章有可能对、有可能错
			- 文章观念不一定适合你或不一定符合你当时的场景（符合作者当时场景）
		- 希望大家就去研究一下，原理是什么样子的？大概是怎么实现的？实现的方法是什么样子的？如果是你，你会怎么做选择？而不是通过人云亦云，去分析、总结别人所说的话来得到，而这面试官很容易发现
	- 关于看源码
		- 各个击破，从被依赖最多的地方开始。
		- 应该是核心代码，最开始应当是简单功能，有对应的测试用例；
		- 然后找到实现的输入输出，找到他的文档，再分析在这个输入输出下是怎么实现的。这样就可以攻破一个模块，再慢慢串起来。
		- 这个过程中需要写一些笔记、博客去跟踪你的学习过程，然后串起来，逐渐成为你自己的东西。
		- 参照课程React部分，看是怎么做的。


### 前端测试
- 测试是为了什么？
	- 填鸭式 → 测试驱动
	- 美国教学方式，测试用例，写代码实现，自动跑测试用例，自动打分
	- 学生知道输入输出是什么，会自己去验证自己的代码，老师只需要关注最终得分

- 测试驱动强制要求你：
	- 单元尽量解耦，否则单元不可测
		- 解耦后，每个单元都有自己的输入输出，这样才**好测**
		- **好看**的代码也是如此，代码结构好，每个结构都有明确的输入输出
	- 开发前先设计接口，再实现细节
		- 由于测试原因，要求是这个能力，所以需要先设计下输入输出，否则我的实现可能是不对的
	- 便于回归和内部代码重构
		- 由于单元高度解耦，所以单元很容易替换
		- 现有测试可复用，测试重构后的代码能否保证以前的正确性，现在代码能不能保证以前的输入输出
		- 以及新加的一些功能能不能实现

- 反例：[TSW开源时没有做测试用例](https://www.zhihu.com/question/278016044)
	- 现在的前端系统，更多通过工程化代码、测试等逐渐去保证一个系统的稳定性，但最上面的系统可能还是没有测试用例，那没关系，那是变化太高的地方

- Node测试、UI测试、CI测试、不测试该怎么选择？哪些需要测试，哪些不需要测试？比如说核心逻辑需要，而UI不需要，因为暂时UI可能变动太频繁。UI测试如何简化？

- Exercise1
	- Node的assert库作用及基本断言方法总结（待补充）
	- mocha是什么，怎么做测试？（待补充）
	- 练习里assert.throw()应该更加精确验证错误是什么样的（代码待优化）

- Exercise2
	- TDD和BDD的差别
		- 去了解BDD的历史，提出BDD想法的同学本质想产品用BDD方式去写需求文档本身也在写测试用例（要不然测试用例需要单独写），解决跨团队合作的事情，所以可以理解BDD为从产品的视角来写测试用例。
			- 为什么提出BDD？
			- BDD为了解决什么问题？
			- BDD到底有什么好处？
		- 网上对比文章没有意义
		- 一个是从测试角度去讲输入输出应该是什么样子的（输入怎么样，结果怎么样）
		- 一个是从行为的角度告诉你干了什么得到什么结果（初始是什么样子）
	- should.js的API（选型为什么用BDD，为什么用should.js，写起来简单就用了）
	- 别人问我源代码怎么看？两套方法论
		- 从最底层开始看起，从被依赖最多的地方看起，逐渐突破
		- 先想想should.js的API，要是我会怎么实现？看看别人怎么实现的？我的实现好，还是别人的实现好？
	- 为什么要大数相加？大数相加更好的实现方案
		- [https://github.com/FE-star/exercise2/issues/12](https://github.com/FE-star/exercise2/issues/12)

- Exercise3
	- 前两者都是在Node环境中的，那在浏览器中是这么跑的呢？
	- 本地watch，CI应该是个single run
	- Karma？能干吗？
	- Travis CI
		- 什么是持续集成？和自动化测试、自动化部署、自动化上线有什么差别？
		- 对测试保障是有非常高的要求的。
		- 持续集成的理论自己查资料
		- 怎么用？

- homework1
	- 算法课程推荐？（+老师貌似忘了+CS61B）

- 其他
	- 这个课程到底要干什么
		- 知道怎么用一个东西
		- 知道这个东西的原理是什么
		- 在自己的环境下应该怎么做选择
		- 选择后知道怎样成本是最低的
	- 你知道怎么做测试不一定代表你在工作中要用，因为你工作中不一定有必要去用（比如说创业初期，会经常变化。但企业从创业转中型，测试才有意义）
	- 在你的企业里面，在工作环境下，是有一些context、环境变量是让你做出一些选择的。而且这些环境变量是由着公司发展、人员结构变化、业务形态变化等会有一定的变形的，不一定是一成不变的。这时候你所学的东西就会有用处。你能够超出你公司目前所处的情况，做出正确的选择，这才是你厉害的地方。而不是说公司需要什么，你才做什么。
	- 要用的时候要有能力去用，而不是要用的时候采取主动学习，这个时候学习成本很高的
	- 所以这个课程内的知识点（测试、跨域解决方案、正则等），可能现在公司不会去用，但你要知道怎么样使用，原理是什么，然后在你当前环境下应该做什么样的选型才是正确的，要知道为什么不用，为什么用，接下来怎样把成本控制到足够低。不要完全限制于我知道就够了，应该更加深入的走进去。当环境变化的时候，你应该立刻可以知道自己有些东西是可以做的。
	- 怎么学习（课前Q2），也是学习的套路，需要贯穿的东西
		- 你要知道任何的技术应该怎么去使用，至少用完这个流程，比如React，你应该至少去使用它
		- 你要知道他的原理，不知道原理，是没办法去判断优劣的。不知道原理，没有说话权。没用过就更没有说话权。
		- 用过，也知道原理后，你应该知道他的优劣是什么。在什么样的环境下应该怎么做出选择，比如Vue、React、Angular
			- 上手成本低，需要人开发-Vue
			- 后台很好配合，企业型系统-Angular
		- 做完选择之后，你应该知道怎样控制/降低成本
			- UI库
			- 工程化
			- 解决方案
			- 流程
		- 然后再有精力去做别的有意思的事情
	- 这也是面试官的方法、优秀公司工作做事的套路、所以也要用这样的方法去工作和学习。
	- 学完再做模拟面试
	- 最好每周写点东西，把你知道的转化成能讲出来的非常难（从你知道，到你能够跟不懂的人说清楚。需要重新研究一遍，把自己都不清楚的地方哇清楚）