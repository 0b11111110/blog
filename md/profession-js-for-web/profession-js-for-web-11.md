- 继承
 - 传统OO语言都支持两种继承方式：
    - 接口继承：只继承方法签名（**因为ECMAScript的函数没有签名，所以无法实现接口继承**）
    - 实现继承：ECMAScript只支持实现继承，主要依靠**原型链**实现。
- 原型链
    - 构造函数、原型和实例的关系：**每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针**
        - 每个构造函数（其实是每个函数都有这个属性）都有一个`prototype属性`，这个属性默认指向的是一个对象（即`原型对象`）。构造函数本质也是函数，会包含一个指向`Function.prototype`的内部属性`[[Prototype]]`
        - `默认指向的原型对象`会默认包含一个`constructor属性`，并指向构造函数。原型对象会包含一个指向`Object.prototype`的内部属性`[[Prototype]]`
        - 通过new调用构造函数创建的实例对象会包含一个指向原型对象的内部属性`[[Prototype]]`
        - 这里需要说明的是：
            - 所有对象都会默认包含一个指向其原型对象的内部属性`[[Prototype]]`
            - 只有函数对象才会默认包含`prototype属性`
            - 只有**默认**的原型对象才会默认包含`constructor属性`
        - 关系如下图所示：
            - ![]()
    - 原型链怎么产生？**假设我们让原型对象等于另一个类型的实例**（重写了原型对象）
